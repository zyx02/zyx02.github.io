<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[洛谷神帖]]></title>
    <url>%2F2019%2F03%2F11%2F%E6%B4%9B%E8%B0%B7%E7%A5%9E%E5%B8%96%2F</url>
    <content type="text"><![CDATA[1.炸出10几个管理员2.A+B problem3.洛谷新闻]]></content>
      <tags>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树学习笔记]]></title>
    <url>%2F2019%2F03%2F11%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.线段树的作用 给定一个整数序列，让你完成如下操作 修改序列上某个位置（区间）上的数 询问序列中某个区间的和 “暴力”算法 单点修改$O(1)$ 询问区间和$O(区间长度)$ “前缀和”算法 单点修改$O(区间长度)$ 询问区间和$O(1)$ 线段树$O(nlogn)$ 2.线段树的概念 线段树是一棵二叉树，树上的每个结点对应序列的一段区间 3.线段树的操作1.结构体1234struct node&#123; int l,r,w,f;//l,r代表左，右端点，w代表这一段区间和，f是懒标记（懒标记在之后会提到）&#125;tree[4*n];//线段树要开到4倍的空间 2.建树基本思想： 1 二分 2 对于二分到的每一个结点，把左右端点的信息储存 3 叶结点输入 12345678910111213void build(int l,int r,int k)&#123; tree[k].l =l,tree[k].r =r; if(tree[k].l==tree[k].r)//叶子结点 &#123; scanf("%d",&amp;tree[k].w); return; &#125; int m=(l+r)/2; build(l,m,k*2);//左孩子 build(m+1,r,k*2+1);//右孩子 tree[k].w =tree[k*2].w +tree[k*2+1].w ;//合并&#125; 3.单点查询123456789101112void ask(int k)&#123; if(tree[k].l ==tree[k].r )//是目标结点 &#123; ans=tree[k].w ;//储存答案 return; &#125; if(tree[k].f ) down(k);//下传懒标记 int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) ask(k*2);//在左边递归左孩子 else ask(k*2+1);//在右边递归右孩子&#125; 4.单点修改12345678910111213void add(int k)&#123; if(tree[k].l ==tree[k].r )//是目标结点 &#123; tree[k].w +=y;//修改 return; &#125; if(tree[k].f ) down(k);//懒标记下传 int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) add(k*2);//在左边递归左孩子 else add(k*2+1);//在右边递归右孩子 tree[k].w =tree[k*2].w +tree[k*2+1].w ;//状态修改&#125; 5.区间求和123456789101112void sum(int k)&#123; if(tree[k].l &gt;=x&amp;&amp;tree[k].r &lt;=y)//左右端点全在目标区间内 &#123; ans+=tree[k].w ;//答案直接加上这一段区间和 return; &#125; if(tree[k].f ) down(k);//懒标记下传 int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) sum(k*2);//往左孩子移 if(y&gt;m) sum(k*2+1);//往右孩子移&#125; 6.区间修改在前面的操作中我们经常看到有懒标记下传这个操作，那么懒标记到底是什么呢 1.1懒标记的作用 存储到这个节点的更新信息，暂时不把更新信息传到子节点。 1.2懒标记的下传 1 将当前节点的懒标记累加到子节点的懒标记中 2 修改子节点状态，即区间和$w$=原状态+区间长度×父节点下传的懒标记 3 父节点懒标记清空 12345678void down(int k)&#123; tree[k*2].f +=tree[k].f ;//修改子节点懒标记(下同) tree[k*2+1].f +=tree[k].f ; tree[k*2].w +=tree[k].f *(tree[k*2].r -tree[k*2].l +1);//修改子节点状态(下同) tree[k*2+1].w +=tree[k].f *(tree[k*2+1].r -tree[k*2+1].l +1); tree[k].f =0;//懒标记清零&#125; 2.区间修改1234567891011121314void add2(int k)//y为增加的数，(a,b)为目标区间&#123; if(tree[k].l &gt;=a&amp;&amp;tree[k].r &lt;=b)//在目标左右端点内 &#123; tree[k].w +=(tree[k].r -tree[k].l +1)*y;//状态修改 tree[k].f +=y;//懒标记加上y return; &#125; if(tree[k].f) down(k);//懒标记下传 int m=(tree[k].l +tree[k].r )/2; if(a&lt;=m) add2(k*2);//如区间求和(下同) if(b&gt;m) add2(k*2+1); tree[k].w =tree[k*2].w +tree[k*2+1].w ;//修改状态&#125; 4.完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; long long l,r,w,f;&#125; tree[400001];long long ans,x,y,a,b,n,p,m;void build(int l,int r,int k)//建树 &#123; tree[k].l =l,tree[k].r =r; if(tree[k].l==tree[k].r) &#123; scanf("%lld",&amp;tree[k].w); return; &#125; int m=(l+r)/2; build(l,m,k*2); build(m+1,r,k*2+1); tree[k].w =tree[k*2].w +tree[k*2+1].w ;&#125;void down(int k)//懒标记下传 &#123; tree[k*2].f +=tree[k].f ; tree[k*2+1].f +=tree[k].f ; tree[k*2].w +=tree[k].f *(tree[k*2].r -tree[k*2].l +1); tree[k*2+1].w +=tree[k].f *(tree[k*2+1].r -tree[k*2+1].l +1); tree[k].f =0;&#125;void ask(int k)//单点查询 &#123; if(tree[k].l ==tree[k].r ) &#123; ans=tree[k].w ; return; &#125; if(tree[k].f ) down(k); int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) ask(k*2); else ask(k*2+1);&#125;void add(int k)//单点修改加法 &#123; if(tree[k].l ==tree[k].r ) &#123; tree[k].w +=y; return; &#125; if(tree[k].f ) down(k); int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) add(k*2); else add(k*2+1); tree[k].w =tree[k*2].w +tree[k*2+1].w ;&#125;void sum(int k)//区间求和 &#123; if(tree[k].l &gt;=x&amp;&amp;tree[k].r &lt;=y) &#123; ans+=tree[k].w ; return; &#125; if(tree[k].f ) down(k); int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) sum(k*2); if(y&gt;m) sum(k*2+1);&#125;void add2(int k)//区间修改加法 &#123; if(tree[k].l &gt;=a&amp;&amp;tree[k].r &lt;=b) &#123; tree[k].w +=(tree[k].r -tree[k].l +1)*y; tree[k].f +=y; return; &#125; if(tree[k].f) down(k); int m=(tree[k].l +tree[k].r )/2; if(a&lt;=m) add2(k*2); if(b&gt;m) add2(k*2+1); tree[k].w =tree[k*2].w +tree[k*2+1].w ;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;m);//n个数和m个操作 build(1,n,1);//建树 for(int i=1; i&lt;=m; i++) &#123; scanf("%lld",&amp;p); ans=0; switch(p) &#123; case 1:&#123;//1为单点查询 cin &gt;&gt; x; ask(1); printf("%lld\n",ans); break; &#125; case 2:&#123;//2为单点修改 cin &gt;&gt; x &gt;&gt; y; add(1); break; &#125; case 3:&#123;//3为区间求和 cin &gt;&gt; x &gt;&gt; y ; sum(1); printf("%lld\n",ans); break; &#125; case 4:&#123;//4为区间修改 cin &gt;&gt; a &gt;&gt; b &gt;&gt; y; add2(1); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF32A 【Reconnaissance】]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3-CF32A-%E3%80%90Reconnaissance%E3%80%91%2F</url>
    <content type="text"><![CDATA[一看到了求方案数，马上想到了枚举 $dfs$ 深搜思路：$dfs(t)$ ($t$为选了几个人) 1 如果已经选取了两个数，$ans$++并$return$ 2 枚举$1\sim n$ 如果第$a_{i}$个人没被选过且与前一个人身高差的绝对值不超过$d$，则标记为已选并$dfs(t+1)$ Code12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;int n,d,a[1010],ans,s[1010];//s用来存前一个人的身高bool p[1010];//p用来标记已选过的人void dfs(int t)&#123; if(t&gt;2) &#123; ans++; return; &#125; for(int i=1; i&lt;=n; i++) &#123; s[0]=a[i];//s[0]需要设成a[i]，这样第一个人才能选 if(abs(a[i]-s[t-1])&lt;=d&amp;&amp;!p[i]) &#123; p[i]=1; s[t]=a[i];//记录前一个人的身高 dfs(t+1); p[i]=0;//回溯 &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;d); for(int i=1; i&lt;=n; i++) &#123; scanf("%d",&amp;a[i]); &#125; dfs(1); printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>C++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF25B 【Phone numbers】]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3-CF25B-%E3%80%90Phone-numbers%E3%80%91%2F</url>
    <content type="text"><![CDATA[一道字符串模拟题首先我们知道 偶数+偶数=偶数 偶数+奇数=奇数 然后我们就可以对$N$进行分类讨论： 当$N\le3$时，直接输出字符串即可 当$N=2k$ $(k\ge2)$时，可以把$N$拆分成若干个长度为2的字符串，在两个字符串之间添上-号 当$N=2k+1$ $(k\ge2)$时，可以把$N$拆分成一个长度为3的字符串和若干个长度为2的字符串，在两个字符串之间添上-号 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;string s;int sum;int n;int main()&#123; scanf("%d",&amp;n); cin&gt;&gt;s; if(n&lt;=3) //如果n&lt;=3，直接输出 &#123; cout&lt;&lt;s; return 0; &#125; if(n%2==0) //n为偶数则拆分成若干个长度为2的字符串 &#123; for(int i=0; i&lt;n; i++) &#123; sum++; printf("%c",s[i]); if(i==n-1) return 0; if(sum==2) &#123; printf("-"); sum=0; &#125; &#125; &#125; else //n为奇数则拆分成一个长度为3的字符串和若干个长度为2的字符串 &#123; for(int i=0; i&lt;3; i++) &#123; printf("%c",s[i]); &#125; printf("-"); for(int i=3; i&lt;n; i++) &#123; sum++; printf("%c",s[i]); if(i==n-1) return 0; if(sum==2) &#123; printf("-"); sum=0; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>C++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 AT3523 【OddString】]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3-AT3523-%E3%80%90OddString%E3%80%91%2F</url>
    <content type="text"><![CDATA[如题，输出奇数位上的字母即可AC 注意字符串下标是从0开始的！ Code12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;char s[100010];int main()&#123; gets(s); for(int i=0;i&lt;strlen(s);i+=2)//输出奇数位 &#123; printf("%c",s[i]); &#125; printf("\n");//记得换行 return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>C++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 AT2201 【鏡文 / Mirror String】]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3-AT2201-%E3%80%90%E9%8F%A1%E6%96%87-Mirror-String%E3%80%91%2F</url>
    <content type="text"><![CDATA[一道简单的字符串模拟，刷难度真给力 本蒟蒻的思路比较麻烦，但个人认为比较好理解 1 先将字符串倒序存放 2 按照规则改变字母 3 比较 Code：1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;char s1[100010],s2[100010];int len;int main()&#123; cin&gt;&gt;s1; for(int i=strlen(s1)-1; i&gt;=0; i--) &#123; s2[len++]=s1[i];//倒序存放 &#125; for(int i=0; i&lt;strlen(s2); i++) &#123; switch(s2[i])//按照规则改变字母 &#123; case 'b': &#123; s2[i]='d'; break; &#125; case 'd': &#123; s2[i]='b'; break; &#125; case 'p': &#123; s2[i]='q'; break; &#125; case 'q': &#123; s2[i]='p'; break; &#125; &#125; &#125; if(strcmp(s1,s2)==0) cout&lt;&lt;"Yes"&lt;&lt;endl;//比较，注意如果两个字符串一样，strcmp返回0 else cout&lt;&lt;"No"&lt;&lt;endl;//记得换行 return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>C++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解CF45I【TCMCF+++】]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3CF45I%E3%80%90TCMCF-%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目大意：给你$N$个整数，让你从中选$r$个数($0&lt;r \leq N$)，使得它们的乘积最大。输出任意一组解 思路：（大佬勿喷） 1 我们知道几个正整数的乘积总是正数，所以遇到正整数直接输出就好啦 2 遇到负数就不同了，我们知道“奇负偶正”，于是就有两种情况： 1 如果有偶数个负数，因为“偶正”，所以全部输出 2 如果有奇数个负数，我们只能输出个数-1个负数，并且这些负数的绝对值最大 3 接下来还需要三个特判 特判1：如果$N=1$并且这个数小于等于0，输出这个数 特判2：如果$N$（$N&gt;1$）个整数全是0，输出0 特判3：如果$N$（$N&gt;1$）个整数中全是非正数（只有0和负数），如果只有1个负数并且0的个数不为0，输出0（因为0比负数大） 4 然后。。。你就AC了 code123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[110],sum1=0,sum2=0;//sum1统计0的个数，sum2统计负数的个数int main()&#123; scanf("%d",&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf("%d",&amp;a[i]); if(a[i]&lt;0) sum2++;//a[i]是负数，sum2++ else if(a[i]==0) sum1++;//a[i]是0，sum1++ else printf("%d ",a[i]);//a[i]是正数，输出！ &#125; sort(a+1,a+n+1);//因为要取绝对值最大的负数，所以先排序 if(sum2%2==0)//偶数个负数全部输出 &#123; for(int i=1; i&lt;=sum2; i++) &#123; printf("%d ",a[i]); &#125; &#125; else//奇数个负数输出个数-1个 &#123; for(int i=1;i&lt;=sum2-1;i++) &#123; printf("%d ",a[i]); &#125; &#125; if(n==1&amp;&amp;a[1]&lt;=0) &#123; cout&lt;&lt;a[1]; return 0; &#125; if(sum1==n) cout&lt;&lt;0;//全是0 if(sum1+sum2==n&amp;&amp;sum2==1) cout&lt;&lt;0;//全是负数和0且负数只有一个 return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>C++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解CF545D【Queue】]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3CF545D%E3%80%90Queue%E3%80%91%2F</url>
    <content type="text"><![CDATA[这道题基本思路就是贪心（标签里的队列是什么鬼不会是因为标题叫队列吧）主要还是证明贪心的正确性(大佬勿喷) 设总等待时间为 $time$ , $n$个人等待时间分别为$t_{1}$,$t_{2}$,$t_{3}$···$t_{n}$,要使总等待人数最少,则$time$ 要取最小值: $time$ = $t_{1}$+($t_{1}$+$t_{2}$)+($t_{1}$+$t_{2}$+$t_{3}$)+···+($t_{1}$+$t_{2}$+$t_{3}$+···$t_{n}$) $time$ = $n \cdot t_{1}$+ $(n-1)\cdot t_{2}$+ ··· + $t_{n}$ 当$t_{1} \le $ $t_{2} \le$ ······ $t_{n}$ 时，$time$为最小值(简单的证明过程) —————————————————————————————————————————— 所以只要先每个人的等待时间排序一遍，设定一个总时间变量$time$,只要$time$小 于这个人的等待时间答案就+1，同时$time$也要加上这个人的等待时间 代码 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int n,t[100010],sum,ti;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;t[i]); sort(t+1,t+n+1);//排序（从小到大) for(int i=1;i&lt;=n;i++) &#123; if(t[i]&gt;=ti)//如果time&lt;这个人等待时间 &#123; sum++;//答案+1 ti+=t[i];//time加上这个人的等待时间 &#125; &#125; printf("%d",sum); return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>C++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解P1049【装箱问题】]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3P1049%E3%80%90%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[看到好多大佬都用动规，这题数据范围太水了(n&lt;=30)于是本蒟蒻先来发篇dfs深搜思路： 把n个物品两种可能（取与不取）都搜一遍，得到的最小体积就是答案 具体解释看代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int v,n,w[40],minx=INT_MAX;//minx存放最小体积，初始赋最大值void dfs(int volume,int pointer)//volume代表当前体积//pointer指示第pointer个物品&#123; if(volume&lt;0) return;//首先需要判断如果体积&lt;0就退出 if(pointer&gt;n)//如果n个物品都搜过了 &#123; if(volume&lt;minx)//判断当前体积是否小于最小体积 minx=volume;//是的话更新最小体积 return; &#125; if(volume==0)//小小的剪枝，如果当前体积已经为0了，那么不可能有更优解 &#123; minx=0; return; &#125; dfs(volume-w[pointer],pointer+1);//取该件物品 dfs(volume,pointer+1);//不取该件物品&#125;int main()&#123; scanf("%d%d",&amp;v,&amp;n); for(int i=1; i&lt;=n; i++) scanf("%d",&amp;w[i]); dfs(v,1); printf("%d",minx);//minx存放的即为答案 return 0;&#125; 但是如果数据范围加大了话。。。其实本题就是把0-1背包中物品的价值与体积画了个等号，于是本题就变成了一道0-1 背包模板题 代码如下：12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int w[31],f[20010];int main()&#123; int v,n; scanf("%d%d",&amp;v,&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); for(int i=1;i&lt;=n;i++) for(int j=v;j&gt;=w[i];j--) if(f[j]&lt;f[j-w[i]]+w[i]) f[j]=f[j-w[i]]+w[i];//状态转移方程 printf("%d",v-f[v]);//最后用体积减去最优解 return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>C++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解P1451【求细胞数量】]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3P1451%E3%80%90%E6%B1%82%E7%BB%86%E8%83%9E%E6%95%B0%E9%87%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[一道可以用dfs做的题目（大佬勿喷）总体思路如下： 1 用一个bool数组存放每个位置是否为细胞数字 2 输入，如果这个数大于0，把这个位置标记为1 3 枚举每一个位置，如果是细胞数字就开始搜，同时答案加1 4 输出 深搜部分： 1 把这个位置标记为0 2 枚举四个方向，如果是细胞数字就从这个位置继续搜 （就是把所有连通的细胞数字都标记为0，周围再也没有细胞数字了就代表一个细胞） 代码如下：123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,sum;char s;bool p[110][110];int a[4]=&#123;1,-1,0,0&#125;;//四个方向int b[4]=&#123;0,0,-1,1&#125;;void dfs(int x,int y) &#123; p[x][y]=0;//把这个位置标记为0 for(int i=0;i&lt;4;i++) &#123; int xx=x+a[i]; int yy=y+b[i]; if(p[xx][yy])//如果这个位置是细胞数字，从这个位置开始搜 dfs(xx,yy); &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; cin&gt;&gt;s; if(s&gt;'0') p[i][j]=1;//是细胞数字标记为1 &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; if(p[i][j])//如果是细胞数字开始搜 &#123; sum++; dfs(i,j); &#125; &#125; printf("%d",sum); return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>C++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2F2019%2F03%2F10%2FNOIP2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[我才不会告诉你这篇文章是用来测验$LaTeX$的 $Day $ $0$告别期中考，来到福州，与机房的各位大佬去试了一下机，回来的时候互奶着哪位大佬要 $AK$了， 哪位大佬要省一了，晚上不务正业地玩着狼人杀，似乎忘记了此行的目的。 $Day$ $1$早上很早地就起来看一本通了，在宾馆颓了一早上，到了要比赛时才匆匆忙忙地背了一下$DP$ 方程 进入考场，先用了5$min$看了一遍所有题目，发现不简单 先看了一下$T1$，一道十分简单的字符串模拟，花了5$min$就敲完了，怕有坑不知道看了几遍题面。。。 看了一下$T2$，题目叙述比较长，于是先去看了看$T3$，想了一会儿觉得是贪心，于是打了个贪心调了挺久的，把两个小样例过了再去看大样例，发现答案比正确答案少了很多，于是想了很多方法，最终还是没想出来。 又回过头去看$T2$,理解完题面意思后发现是一道模拟，下意识写了个$O(N^{2})$的暴力，发现大数据会卡，脑抽没发现$O(n)$的算法，又去调了一会$T3$ 最后30$min$去看了一眼$T4$，发现是二叉树，但是没学过，直接输出0想骗些分 比赛结束，预计得分:$100+80+30+10=220$ 赛后去你谷测了一下民间数据，发现得分比预期的高，$100+80+30+20=230$ 用老师的数据也测了一下，$210$也还好 最后CCF的官方成绩出来了，发现才$100+80+10+4=194$分，原来$T3$的正解是$DP$，发现如果在原来的贪心上再改动一点应该可以过更多的数据的 最后$FJ$的分数线出来了——$195$，$194$的我当场崩溃$QwQ$ 第一次参加$NOIP$就带着差一分省一的遗憾结束了，不过反正我才初一还有很多机会对吧]]></content>
      <tags>
        <tag>NOIP</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A+B problem]]></title>
    <url>%2F2019%2F03%2F10%2FA-B-problem%2F</url>
    <content type="text"><![CDATA[纪念博客的诞生QwQ123456789#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a,b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a+b; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
